# Тема 9. ООП на Python: концепции, принципы и примеры реализации
Отчет по Теме #9 выполнил:
- Верхотуров Иван Сергеевич
- ПИЭ-21-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + |  |
| Задание 3 | + |  |
| Задание 4 | + |  |
| Задание 5 | + |  |

# Лабораторная работа

## Задание 1
Допустим, что вы решили оригинально и немного странно познакомится  с человеком. Для этого у вас должен быть написан свой класс на Python,  который будет проверять угадал ваше имя человек или нет. Для этого  создайте класс, указав в свойствах только имя. Дальше создайте  функцию __init__(), а в ней сделайте проверку на то угадал человек ваше  имя или нет. Также можете проверить что будет, если в этой функции  указав атрибут, который не указан в вашем классе, например,  попробуйте вызвать фамилию.

  ```python
class  Ivan:
    __slots__ = ["name"]

    def __init__(self, name):
        if name == "Иван":
            self.name = f"Да, я {name}"
        else:
            self.name = f"Я не {name}, а Иван"
person1 = Ivan("Алексей")
person2 = Ivan("Иван")
print(person1.name)
print(person2.name)

person2.supername = "Петров"
```
### Результат
![Desktop_231124_1929](https://github.com/d1VaN47/Software_Engineering/assets/145551753/173f30e0-977b-4a47-845d-ef092c1653c3)

## Краткий вывод:
Для выполнения задания создаём класс в котором ограничиваем атрибуты класса с помощью __slots__, далее создаём метод который на вход получает имя и проверяет его на совпадение с необходимым, а после выводим результат.

## Задание 2
Вам дали важное задание, написать продавцу мороженого программу,  которая будет писать добавили ли топпинг в мороженое и цену после  возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом  классе реализуйте метод, выводящий на печать «Мороженое с  {ТОППИНГ}» в случае наличия добавки, а иначе отобразится  следующая фраза: «Обычное мороженое». При этом программа должна  воспринимать как топпинг только атрибуты типа string.

  ```python
class Icecream:
    def __init__(self, ingridient=None):
        if isinstance(ingridient, str):
            self.ingridient = ingridient
        else:
            self.ingridient = None

    def composition(self):
        if self.ingridient:
            print(f"Мороженное с {self.ingridient}")
        else:
            print(f"Обычное мороженое")

icecream = Icecream()
icecream.composition()
icecream = Icecream("шоколадом")
icecream.composition()
icecream = Icecream(5)
icecream.composition()
```
### Результат
![Desktop_231124_1941](https://github.com/d1VaN47/Software_Engineering/assets/145551753/9545d915-2e2f-4349-9a5b-f49e99e007ae)

## Краткий вывод:
Для выполнения задания создаём класс с 2я методами, первый из которых проверяет был ли использован топинг. А второй метод выводит сообщение о том какое мороженое было продано с учётом того, был ли использован топинг, если да, то какой.

## Задание 3
Петя – начинающий программист и на занятиях ему сказали реализовать  икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно  знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь  вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не  просто инкапсуляцией, а классом с сеттером, геттером и деструктором.  После написания класса вам необходимо продемонстрировать что все  написанные вами функции работают.  Также вас необходимо объяснить Пете почему на скриншоте ниже в  консоли выводится ошибка.

  ```python
class MyClass:
    def __init__(self, value):
        self._value = value
    def set_value(self,value):
        self._value = value
    def get_value(self):
        return self._value
    def del_value(self):
        del self._value
    value = property(get_value, set_value, del_value, "Свойства value")
obj = MyClass(42)
print(obj.get_value())
obj.set_value(45)
print(obj.get_value())
obj.set_value(100)
print(obj.get_value())
obj.del_value()
print(obj.get_value())
```
### Результат
![Desktop_231124_1956](https://github.com/d1VaN47/Software_Engineering/assets/145551753/f1246aef-34eb-466b-9011-1ce84df33147)

## Краткий вывод:
Для выполнения задания создаём класс в котором создаём методы на удалиение, изменение и вывод. Далее вызываем их все по очереди и выволдим результат. После выполнения выдало ошибку, так как мы пытаемсявывести аргумент который удалили с помощью del

## Задание 4
Вам прекрасно известно, что кошки и собаки являются  млекопитающими, но компьютер этого не понимает, поэтому вам нужно  написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это  млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек  и собак, чтобы показать, что они чем-то отличаются друг от друга.

  ```python
class Mammal:
    className = "Mammal"

class Dog(Mammal):
    species = "canine"
    sounds = "wow"

class Cat(Mammal):
    species = "feline"
    sounds = "meow"

dog = Dog()
print(f"Dog is {dog.className}, but they say {dog.sounds}")
cat = Cat()
print(f"Cat is {cat.className}, but they say {cat.sounds}")
```
### Результат
![Desktop_231124_2202](https://github.com/d1VaN47/Software_Engineering/assets/145551753/043aa7c0-7dfe-4292-996d-6a0f576e5015)

## Краткий вывод:
Для выполнения задания мы создали 3 класса, один из которых главный Mammal, а остальные 2 его наследуют с помощью "class Dog(Mammal):"

## Задание 5
На разных языках здороваются по-разному, но суть остается  одинаковой, люди друг с другом здороваются. Давайте вместе с вами  реализуем программу с полиморфизмом, которая будет описывать всю  суть первого предложения задачи. Для этого мы можем выбрать два  языка, например, русский и английский и написать для них отдельные  классы, в которых будет в виде атрибута слово, которым здороваются на  этих языках. А также напишем функцию, которая будет выводить  информацию о том, как на этих языках здороваются.  Заметьте, что для решения поставленной задачи мы использовали  декоратор @staticmethod, поскольку нам не нужны обязательные  параметры-ссылки вроде self.

  ```python
class Russian:
    @staticmethod
    def greeting():
        print("Привет")

class English:
    @staticmethod
    def greeting():
        print("Hello")

def greet(language):
    language.greeting()

Ivan = Russian()
greet(Ivan)
John = English()
greet(John)
```
### Результат
![Desktop_231124_2208](https://github.com/d1VaN47/Software_Engineering/assets/145551753/d221a16a-7735-4e8e-a62b-d4cc8c20aac5)

## Краткий вывод:
Для выполнения задания мы создали 2 класса с @staticmethod и 1 метод в который на вход мы подаём экземпляр класса и он вызывает приветствие в консоль.

# Самостоятельная работа
## Задание 1
Задание Садовник и помидоры.

```python
class Tomato:
    states = {"Отсутствует": 0, "Цветение": 1, "Зеленый": 2, "Красный": 3}
    def __init__(self, index):
        self._index = index #защищённый атрибут
        self._state = self.states["Отсутствует"] #защищённый атрибут
    def grow(self):
        if self._state < 3:
            self._state += 1
    def is_ripe(self):
        if self._state == 3:
            return True
class TomatoBush:
    def __init__(self, kol_vo):
        self.tomatoes = [Tomato(index) for index in range(1, kol_vo + 1)]
    def grow_all(self):
        for i in self.tomatoes:
            i.grow()
    def all_are_ripe(self):
        a = True
        for i in self.tomatoes:
            if i.is_ripe():
                pass
            else:
                a = False
        return a
    def give_away_all(self):
        self.tomatoes = []
class Gardener:
    def __init__(self, name, plant):
        self.name = name #публичный атрибут
        self._plant = plant #защищённый атрибут
    def work(self):
        self._plant.grow_all()
    def harvest(self):
        if self._plant.all_are_ripe():
            print("Урожай собран")
            self._plant.give_away_all()
        else:
            print("Ещё не все Томаты созрели!")

    @staticmethod
    def knowledge_base():
        print("Справка:\n1.) Регулярно поливайте томаты\n2.) Следите за созреванием плодов\n3.) Если плоды созрели то аккуратно соберите их все")

Gardener.knowledge_base()
bush = TomatoBush(3)
print()
Sadovod = Gardener("Иван", bush)
Sadovod.work()
Sadovod.work()
Sadovod.harvest()
Sadovod.work()
Sadovod.harvest()
```
### Результат
![Desktop_231124_2356](https://github.com/d1VaN47/Software_Engineering/assets/145551753/445ab664-5a38-4280-8b00-5c2c78f0731b)

## Краткий вывод:
Для выполнения задания мы создаём 3 класса.

Первый класс Tomato содержит 3 метода, впервом мы объявляем атрибуты (порядковый номер и стадии созревания), второй метод повышает стадию созревания у выбранного куста, а третий проверяет созрел ли куст.

Второй класс TomatoBush содержит 4 метода. Первый создаёт массив со всеми имеющимися кустами, Второй grow_all повышает стадию созревания у всех кустов, тертий all_are_ripe проверяет все ли кусты созрели, четвёртый give_away_all очищает базу растений (собирает все плоды)

Третий класс Gardener 3 обычных метода и 1 статичный. Первый метод создаёт 2 атрибута (Имя садовника и растение), второй метод work - повышает степень созревания у всех растений на 1 (Ухаживает за томатами), третий класс harvest проверяет все ли томаты созрели, если все, то собироает все томаты (очищает список кустов), если нет то выводит сообщение об этом, а статичный метод knowledge_base выводит справку.
